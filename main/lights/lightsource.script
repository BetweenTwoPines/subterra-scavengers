go.property("color", vmath.vector4(1, 1, 1, 1))
go.property("radius", 256)
go.property("arc_angle", 360)
go.property("falloff", 1)
go.property("static", false)
go.property("enabled", true)

local lights = require "main.lights.lights"

local function update_angle(arc_angle, rotation)
	local x, y, z, w = 0, 0, 0, 0
	local from = (rotation - arc_angle / 2)
	local to = (rotation + arc_angle / 2)
	if from < 0 then
		z = 0
		w = from
		x = 0
		y = to
	elseif from <= 180 then
		x = from
		if to > 180 then
			y = 180
			w = -180
			z = (to - 360)
		else
			y = to
			w = 0
			z = 0
		end
	elseif from > 180 then
		w = (from - 360)
		if to > 360 then
			z = 0
			x = 0
			y = (to - 360)
		else
			z = (to - 360)
			x = 0
			y = 0
		end
	end
	return vmath.vector4(math.rad(x), math.rad(y), math.rad(z), math.rad(w))
end

local function calculate_rotation(origin, mouse_pos)
	local direction = mouse_pos - origin
	local angle = math.atan2(direction.y, direction.x)
	return math.deg(angle)
end

function init(self)
	self.light = lights.add({
		position = go.get_world_position(),
		color = self.color,
		angle = update_angle(self.arc_angle, 0),
		falloff = self.falloff,
		radius = self.radius,
		enabled = self.enabled,
	})
end

function final(self)
	lights.remove(self.light)
end

function update(self, dt)
	if not self.static then
		-- Get mouse position
		local crosshair_pos = go.get_world_position("/crosshair")
		-- Convert mouse position to world position
		local mouse_pos = vmath.vector3(crosshair_pos.x, crosshair_pos.y, 0)

		-- Calculate the rotation angle based on the mouse position
		local origin = go.get_world_position("/player/player")
		local rotation = calculate_rotation(origin, mouse_pos)
		
		lights.set_angle(self.light, update_angle(self.arc_angle, rotation))
		lights.set_position(self.light, go.get_world_position())
		lights.set_light_radius(self.light, self.radius)
		lights.set_color(self.light, self.color)
		lights.set_enabled(self.light, self.enabled)
	end
end