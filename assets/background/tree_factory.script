local SCREEN_WIDTH = sys.get_config("display.width")
-- FIXME: Temporary hardcoded values until i can figure out how to calculate the bottom of the tree root
local OFFSET_Y = { 40, 95, 145 }
local RENDERED_TREE_MAP = {};
local TREE_WIDTH = 250 -- minimal distance between tree sprites
local TREE_GENERATION_INTERVAL = 1

local function tree_position_is_free(x_pos, tree_index)
	local width_constraint = TREE_WIDTH
	if tree_index == 1 or tree_index == 2 then
		width_constraint = 0  -- No spacing constraint for distant trees
	end

	for _, tree_data in pairs(RENDERED_TREE_MAP) do
		if math.abs(tree_data.pos.x - x_pos) < width_constraint then
			return false
		end
	end
	return true
end


local function get_random_distance()
	local intervals = {200, 300, 400}
	local index = math.random(1, #intervals)
	return intervals[index]
end

local function handle_trees_outside_of_viewport(player_pos)
	for tree, tree_data in pairs(RENDERED_TREE_MAP) do
		local distance = math.abs(tree_data.pos.x - player_pos.x)
		if distance > tonumber(SCREEN_WIDTH) and not tree_data.out_of_view_port then
			-- Cleanup trees outside of view port
			go.delete(tree)
			tree_data.out_of_view_port = true;
		elseif distance < SCREEN_WIDTH / 2 + 100 and tree_data.out_of_view_port then
			-- Return trees back into viewport
			local new_tree = factory.create("#factory", vmath.vector3(tree_data.pos.x, tree_data.pos.y, tree_data.pos.z), nil, { index = tree_data.index })
			tree_data.out_of_view_port = false;
			RENDERED_TREE_MAP[new_tree] = tree_data
			RENDERED_TREE_MAP[tree] = nil;
		end
	end
end

local function get_random_tree_pos(self, player_pos, initial)
	-- defined which size of the tree to draw (actual scaling logic inside tree.script)
	local tree_index = math.random(1, 3)
	-- randomize dinstance between trees
	local random_distance = get_random_distance()
	if initial then
		local direction = math.random(-1, 1)
		return vmath.vector3(player_pos.x + random_distance * direction, self.HORIZON_Y + OFFSET_Y[tree_index], 0), tree_index
	else 
		return vmath.vector3(player_pos.x + (SCREEN_WIDTH / 3) * self.direction + random_distance * self.direction, self.HORIZON_Y + OFFSET_Y[tree_index], 0), tree_index
	end
end

local function render_tree(self, tree_pos, tree_index)
	-- Make sure we are not drawing on top of another tree and we are no adding more trees between already existing trees
	if tree_position_is_free(tree_pos.x, tree_index) and (self.max_x < tree_pos.x or self.min_x > tree_pos.x) then
		local tree = factory.create("#factory", vmath.vector3(tree_pos.x, tree_pos.y, tree_pos.z), nil, { index = tree_index })
		RENDERED_TREE_MAP[tree] = {pos = tree_pos, out_of_view_port = false, index = tree_index }
		if self.direction then
			self.max_x = tree_pos.x
		else
			self.min_x = tree_pos.x
		end
	end
end

function init(self)
	local player = go.get_position('/player/player#player')
	self.timer = 0
	self.max_x = 0 -- tracks position of the leftmost tree coordinate
	self.min_x = 0 -- tracks position of the rightmost tree coordinate
	self.HORIZON_Y = player.y
	self.direction = 0

	for i = 1, 3 do
		local tree_pos, tree_index = get_random_tree_pos(self, player, true)
		render_tree(self, tree_pos, tree_index)
	end
end

function update(self, dt)
	-- no need to run this on every frame when player is not moving
	if self.direction ~= 0 then
		self.timer = self.timer + dt
		local player_pos = go.get_position('/player/player#player')
		if self.timer >= TREE_GENERATION_INTERVAL then
			local tree_pos, tree_index = get_random_tree_pos(self, player_pos, false)

			render_tree(self, tree_pos, tree_index)

			self.timer = 0
			-- randomize the limit on the interval so tree generation does not look static
			TREE_GENERATION_INTERVAL = math.random(1, 3)
		end
		handle_trees_outside_of_viewport(player_pos)
	end
	self.direction = 0
end

function on_message(self, message_id, message, sender)
	if message_id == hash('player_moving') then
		self.direction = message.direction
	end
end