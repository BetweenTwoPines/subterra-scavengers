local state = require "main.state.game"

-- Map all ore type sprites here
local ore_types = {
	"/assets/resources/ore.sprite"
}

-- Create and initialize custom game object property
go.property("ore_type_id", 1)

local gravity = state.game_state.get_state_property(state.StateEnum.Physics.Gravity)
local ore_animation_pull_speed = 200

function init(self)
	if self.ore_type_id == state.TileTypeEnum.IRON_ORE then
		self.ore_anim = "silver-ore"
	else 
		self.ore_anim = "gold-ore"
	end
	sprite.play_flipbook("#sprite", self.ore_anim)
	self.velocity = vmath.vector3(1, 500, 0)
	self.random_x_axis_acceleration = math.random(-1, 1) * 100
	
	self.first_render = true
	self.correction = vmath.vector3()
	self.created = false
	self.pickup_in_progress = false
	self.animation_in_progress = false
end

local function pickup(ore_type)
	sound.play(msg.url("/player/player#ore-pickup"))
	local inventory_resources = state.game_state[state.StateEnum.Inventory.Items.Resources]

	-- Check if the ore_type_id already exists in the inventory
	if inventory_resources[ore_type] then
		-- Ore type exists, increment its quantity
		-- inventory_resources[ore_type] = inventory_resources[ore_type] + 1
		inventory_resources[ore_type].count = inventory_resources[ore_type].count + 1
		inventory_resources[ore_type].weight = inventory_resources[ore_type].weight + state.ResourceWeightMap[ore_type]
	else
		-- Ore type does not exist, init with 1
		inventory_resources[ore_type] = {count = 1, weight = state.ResourceWeightMap[ore_type], sprite_url = ore_types[1]}
	end
	-- update total weight of inventory
	state.game_state[state.StateEnum.Inventory.Weight] = state.game_state[state.StateEnum.Inventory.Weight] + state.ResourceWeightMap[ore_type]
	-- update number of resources
	state.game_state[state.StateEnum.Inventory.Items.Resources] = inventory_resources
	msg.post("/gui#ui", "update_inventory")
	msg.post("/main#main", "delete_ore", { id = go.get_id()})
	go.delete()
end

local function animate_pickup(self, dt, ore_position)
	local player_pos = go.get_position("/player/player#player")
	player_pos.y = player_pos.y
	local distance_to_player = vmath.length_sqr(player_pos - ore_position)
	local direction_to_move = vmath.normalize(player_pos - ore_position)

	if distance_to_player < 10 then
		if self.animation_in_progress == false then
			self.animation_in_progress = true
			go.animate(go.get_id(), "position.y", go.PLAYBACK_ONCE_FORWARD,player_pos.y + 50 , go.EASING_LINEAR, 0.2, 0, function ()
				go.animate(go.get_id(), "scale", go.PLAYBACK_ONCE_FORWARD, 1.3, go.EASING_LINEAR, 0.4, 0, function ()
					local ore_type = state.ReverseTileTypeEnum[self.ore_type_id]
					pickup(ore_type)
					self.pickup_in_progress = false;
					self.animation_in_progress = false;
				end)
			end)
		end
	end

	if self.animation_in_progress == false then
		go.set_position(ore_position + direction_to_move * ore_animation_pull_speed * dt)
	end
end

function update(self, dt)
	local ore_position = go.get_position()
	if self.pickup_in_progress then
		-- Handle pulling ore go towards player
		animate_pickup(self, dt, ore_position)
	else 
		-- Apply gravity to the velocity if the object is not grounded
		self.velocity.y = self.velocity.y + gravity * dt

		-- Randomize the x direction of travel
		if self.velocity.x > 0 then
			self.velocity.x = self.random_x_axis_acceleration
		end

		-- Update the position of the game object
		ore_position = ore_position + self.velocity * dt
		go.set_position(ore_position)
	end
	
	-- reset
	self.grounded = false
	self.correction = vmath.vector3()
end

local function handle_obstacle_contact(self, normal, distance)
	if distance > 0 then
		-- First, project the accumulated correction onto
		-- the penetration vector
		local proj = vmath.project(self.correction, normal * distance)
		if proj < 1 then
			-- Only care for projections that does not overshoot.
			local comp = (distance - distance * proj) * normal
			-- Apply compensation
			go.set_position(go.get_position() + comp)
			-- Accumulate correction done
			self.correction = self.correction + comp
		end
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("contact_point_response") then
		if message.group == hash("ground") or message.group == hash("ore") then
			-- HACK: For some reason when we first spawn this object, it triggers collison event which causes jittering in gravity
			-- SKIP first emission
			if not self.first_render then
				handle_obstacle_contact(self, message.normal, message.distance)

				if math.abs(message.normal.x) > 0.7 then
					self.velocity.x = 0
				end

				if message.normal.y > 0.7 then
					self.velocity.y = 0
					self.velocity.x = 0
				end
			else
				self.first_render = false
			end
		elseif message.group == hash("player") then
			-- Disable collision in order to let ore move freely
			msg.post("#ore_collision_object", "disable")
			self.pickup_in_progress = true;
		end
	end
end