function init(self)
	-- Save energy bar node so we can scale it based on players energy
	self.player_energy_node = gui.get_node("player_energy")
	-- Remember initial width of the node so we can reset it back to it when energy resets
	self.energy_bar_intial_scale = gui.get_scale(self.player_energy_node).x
	-- Total possible energy user has. can be increased based on skills, perks, etc.
end

local function update_energy_bar(self, energyBarScaleRatio)
	-- because energy bar's scale is not 1 we need to multiple by its intial scale
	local fill_percentage = energyBarScaleRatio * self.energy_bar_intial_scale
	local current_scale = gui.get_scale(self.player_energy_node)
	local new_scale = vmath.vector3(fill_percentage, current_scale.y, current_scale.z)
	gui.set_scale(self.player_energy_node, new_scale)
end

local function update_round_timer(self, timeleft)
	gui.set_text(gui.get_node("round_timer_text"), "Time remaining: " .. math.ceil(timeleft))
end

function on_message(self, message_id, message, sender)
	if message_id == hash("use_energy") then
		update_energy_bar(self, message.energyRemainingRatio)
	elseif message_id == hash("debug_tile_count") then
		gui.set_text(gui.get_node("debug_tile_count"), ("total: %d, visible: %d"):format(message.total, message.visible))
	elseif message_id == hash("update_round_timer") then
		update_round_timer(self, message.timeleft)
	end
end